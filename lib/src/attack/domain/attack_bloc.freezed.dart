// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'attack_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AttackStateTearOff {
  const _$AttackStateTearOff();

  _AttackState call(
      {required List<PickingGroupAbstract> treatmentsGroup,
      required List<PickingGroupAbstract> symptomsGroup,
      required List<AttackModel> attackList,
      required AttackModel? currentModel,
      required bool isLoading,
      required DateTime? minDate,
      required bool fetchedNewData}) {
    return _AttackState(
      treatmentsGroup: treatmentsGroup,
      symptomsGroup: symptomsGroup,
      attackList: attackList,
      currentModel: currentModel,
      isLoading: isLoading,
      minDate: minDate,
      fetchedNewData: fetchedNewData,
    );
  }
}

/// @nodoc
const $AttackState = _$AttackStateTearOff();

/// @nodoc
mixin _$AttackState {
  List<PickingGroupAbstract> get treatmentsGroup =>
      throw _privateConstructorUsedError;
  List<PickingGroupAbstract> get symptomsGroup =>
      throw _privateConstructorUsedError;
  List<AttackModel> get attackList => throw _privateConstructorUsedError;
  AttackModel? get currentModel => throw _privateConstructorUsedError;
  bool get isLoading => throw _privateConstructorUsedError;
  DateTime? get minDate => throw _privateConstructorUsedError;
  bool get fetchedNewData => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AttackStateCopyWith<AttackState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AttackStateCopyWith<$Res> {
  factory $AttackStateCopyWith(
          AttackState value, $Res Function(AttackState) then) =
      _$AttackStateCopyWithImpl<$Res>;
  $Res call(
      {List<PickingGroupAbstract> treatmentsGroup,
      List<PickingGroupAbstract> symptomsGroup,
      List<AttackModel> attackList,
      AttackModel? currentModel,
      bool isLoading,
      DateTime? minDate,
      bool fetchedNewData});

  $AttackModelCopyWith<$Res>? get currentModel;
}

/// @nodoc
class _$AttackStateCopyWithImpl<$Res> implements $AttackStateCopyWith<$Res> {
  _$AttackStateCopyWithImpl(this._value, this._then);

  final AttackState _value;
  // ignore: unused_field
  final $Res Function(AttackState) _then;

  @override
  $Res call({
    Object? treatmentsGroup = freezed,
    Object? symptomsGroup = freezed,
    Object? attackList = freezed,
    Object? currentModel = freezed,
    Object? isLoading = freezed,
    Object? minDate = freezed,
    Object? fetchedNewData = freezed,
  }) {
    return _then(_value.copyWith(
      treatmentsGroup: treatmentsGroup == freezed
          ? _value.treatmentsGroup
          : treatmentsGroup // ignore: cast_nullable_to_non_nullable
              as List<PickingGroupAbstract>,
      symptomsGroup: symptomsGroup == freezed
          ? _value.symptomsGroup
          : symptomsGroup // ignore: cast_nullable_to_non_nullable
              as List<PickingGroupAbstract>,
      attackList: attackList == freezed
          ? _value.attackList
          : attackList // ignore: cast_nullable_to_non_nullable
              as List<AttackModel>,
      currentModel: currentModel == freezed
          ? _value.currentModel
          : currentModel // ignore: cast_nullable_to_non_nullable
              as AttackModel?,
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      minDate: minDate == freezed
          ? _value.minDate
          : minDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      fetchedNewData: fetchedNewData == freezed
          ? _value.fetchedNewData
          : fetchedNewData // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  $AttackModelCopyWith<$Res>? get currentModel {
    if (_value.currentModel == null) {
      return null;
    }

    return $AttackModelCopyWith<$Res>(_value.currentModel!, (value) {
      return _then(_value.copyWith(currentModel: value));
    });
  }
}

/// @nodoc
abstract class _$AttackStateCopyWith<$Res>
    implements $AttackStateCopyWith<$Res> {
  factory _$AttackStateCopyWith(
          _AttackState value, $Res Function(_AttackState) then) =
      __$AttackStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<PickingGroupAbstract> treatmentsGroup,
      List<PickingGroupAbstract> symptomsGroup,
      List<AttackModel> attackList,
      AttackModel? currentModel,
      bool isLoading,
      DateTime? minDate,
      bool fetchedNewData});

  @override
  $AttackModelCopyWith<$Res>? get currentModel;
}

/// @nodoc
class __$AttackStateCopyWithImpl<$Res> extends _$AttackStateCopyWithImpl<$Res>
    implements _$AttackStateCopyWith<$Res> {
  __$AttackStateCopyWithImpl(
      _AttackState _value, $Res Function(_AttackState) _then)
      : super(_value, (v) => _then(v as _AttackState));

  @override
  _AttackState get _value => super._value as _AttackState;

  @override
  $Res call({
    Object? treatmentsGroup = freezed,
    Object? symptomsGroup = freezed,
    Object? attackList = freezed,
    Object? currentModel = freezed,
    Object? isLoading = freezed,
    Object? minDate = freezed,
    Object? fetchedNewData = freezed,
  }) {
    return _then(_AttackState(
      treatmentsGroup: treatmentsGroup == freezed
          ? _value.treatmentsGroup
          : treatmentsGroup // ignore: cast_nullable_to_non_nullable
              as List<PickingGroupAbstract>,
      symptomsGroup: symptomsGroup == freezed
          ? _value.symptomsGroup
          : symptomsGroup // ignore: cast_nullable_to_non_nullable
              as List<PickingGroupAbstract>,
      attackList: attackList == freezed
          ? _value.attackList
          : attackList // ignore: cast_nullable_to_non_nullable
              as List<AttackModel>,
      currentModel: currentModel == freezed
          ? _value.currentModel
          : currentModel // ignore: cast_nullable_to_non_nullable
              as AttackModel?,
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      minDate: minDate == freezed
          ? _value.minDate
          : minDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      fetchedNewData: fetchedNewData == freezed
          ? _value.fetchedNewData
          : fetchedNewData // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_AttackState implements _AttackState {
  const _$_AttackState(
      {required this.treatmentsGroup,
      required this.symptomsGroup,
      required this.attackList,
      required this.currentModel,
      required this.isLoading,
      required this.minDate,
      required this.fetchedNewData});

  @override
  final List<PickingGroupAbstract> treatmentsGroup;
  @override
  final List<PickingGroupAbstract> symptomsGroup;
  @override
  final List<AttackModel> attackList;
  @override
  final AttackModel? currentModel;
  @override
  final bool isLoading;
  @override
  final DateTime? minDate;
  @override
  final bool fetchedNewData;

  @override
  String toString() {
    return 'AttackState(treatmentsGroup: $treatmentsGroup, symptomsGroup: $symptomsGroup, attackList: $attackList, currentModel: $currentModel, isLoading: $isLoading, minDate: $minDate, fetchedNewData: $fetchedNewData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AttackState &&
            const DeepCollectionEquality()
                .equals(other.treatmentsGroup, treatmentsGroup) &&
            const DeepCollectionEquality()
                .equals(other.symptomsGroup, symptomsGroup) &&
            const DeepCollectionEquality()
                .equals(other.attackList, attackList) &&
            const DeepCollectionEquality()
                .equals(other.currentModel, currentModel) &&
            const DeepCollectionEquality().equals(other.isLoading, isLoading) &&
            const DeepCollectionEquality().equals(other.minDate, minDate) &&
            const DeepCollectionEquality()
                .equals(other.fetchedNewData, fetchedNewData));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(treatmentsGroup),
      const DeepCollectionEquality().hash(symptomsGroup),
      const DeepCollectionEquality().hash(attackList),
      const DeepCollectionEquality().hash(currentModel),
      const DeepCollectionEquality().hash(isLoading),
      const DeepCollectionEquality().hash(minDate),
      const DeepCollectionEquality().hash(fetchedNewData));

  @JsonKey(ignore: true)
  @override
  _$AttackStateCopyWith<_AttackState> get copyWith =>
      __$AttackStateCopyWithImpl<_AttackState>(this, _$identity);
}

abstract class _AttackState implements AttackState {
  const factory _AttackState(
      {required List<PickingGroupAbstract> treatmentsGroup,
      required List<PickingGroupAbstract> symptomsGroup,
      required List<AttackModel> attackList,
      required AttackModel? currentModel,
      required bool isLoading,
      required DateTime? minDate,
      required bool fetchedNewData}) = _$_AttackState;

  @override
  List<PickingGroupAbstract> get treatmentsGroup;
  @override
  List<PickingGroupAbstract> get symptomsGroup;
  @override
  List<AttackModel> get attackList;
  @override
  AttackModel? get currentModel;
  @override
  bool get isLoading;
  @override
  DateTime? get minDate;
  @override
  bool get fetchedNewData;
  @override
  @JsonKey(ignore: true)
  _$AttackStateCopyWith<_AttackState> get copyWith =>
      throw _privateConstructorUsedError;
}
